У додатку дуже прості приклади друку повідомлень через рівні інтервали, виконані через періодичний системний таймер і через hr timer.

Забув сказати на лекції — при старті системи jiffies ініціалізуються великим числом. Так, щоб перехід від Max до 0 з отого малюнка у слайдах відбувся через кілька хвилин, а не через 50..500 днів.
Щоб якщо хтось на такому переході збоїть, то це виявилося раніше.

Докладно про роботу з апаратурою буде на лекціях другої половини курсу, але назабаром нам буде потрібна робота з кнопкою на платі поруч гнізда uSD-карти як джерелом апаратних переривань. Тому додано окремий архів з інструкцією що слід зробити, щоб працювати з цією кнопкою. Заразом там (не зовсім коректний) приклад роботи з тимчасово незадіяними світлодіодами.

Нинішнє домашнє завдання не ділиться на базову та просунуту частину, а складається з кількох кроків.
Що далі просунетеся, то краще. Звичайно, хотілося б, щоб всі встигли зробити все :-)

Крок 1. Підготуйте систему для роботи з кнопкою, перевірте, що кнопка працює
(див. архів onboard_io)

Крок 2. Використовуючи системний періодичний таймер напишіть модуль, який з періодом,
наприклад, 100 мс опитує кнопку і якщо вна натиснена, то вмикає світлодіод, інакше вимикає.

Крок 3. Використовуючи таймер високої роздільної здатності, напишіть модуль, який демонструє
запуск і виконання низькопріоритетного та високопріоритетного тасклетів.

Упевніться, що високопріоритетні тасклети виконуються раніше, навіть якщо в межах
одного виклику функції таймера заплановані пізніше за низькопріоритетні.

Крок 4. З кожного з тасклетів попереднього кроку заплануйте виконання work та delayed work.
Можна використати системні черги (schedule_work, schedule_delayed_work).
При вивантаженні модуля не забудьте скасувати заплановані work-и.

У кроках 3 і 4 друкуйте час планування та виконання кожної операції.
Всі затримки бажано вибирати кратними 100 мс, щоб було простіше звіряти часи подій.

